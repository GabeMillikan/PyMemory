import syssys.path.append('..')from memory import *import mathm = memory()m.attach_by_process_name("ac_client.exe")ac_client = m.get_module("ac_client.exe")offset = {    # from ac_client    'local player' : 0x10f4f4,    'entity list' : 0x10f4f8,        # from player    'x' : 0x4,    'y' : 0x8,    'z' : 0xc,    'yaw' : 0x40,    'pitch' : 0x44,    'roll' : 0x48,    'health' : 0xf8,    'carbine ammo' : 0x140,    'shotgun ammo' : 0x144,    'submachine ammo' : 0x148,    'sniper ammo' : 0x14c,    'rifle ammo' : 0x150,    'ping' : 0x1f0,    'frags' : 0x1fc,    'flags' : 0x200,    'deaths' : 0x204,    'score' : 0x208,    'name' : 0x225,    'team' : 0x32c,}class memvector:    def __init__(self, x = 0, y = 0, z = 0):        self._values = {}                self.s = memory_struct()        self.s.add_offset(0x0, "x", vartype.float)        self.s.add_offset(0x4, "y", vartype.float)        self.s.add_offset(0x8, "z", vartype.float)                self.init(x,y,z)            def init(self, x, y, z):        self['x'] = float(x)        self['y'] = float(y)        self['z'] = float(z)            def __setitem__(self, key, value):        self._values[key] = value        def __getitem__(self, key):        return self._values[key]            def write(self, addr):        self.s.set_base(addr)        self.s['x'] = self['x']        self.s['y'] = self['y']        self.s['z'] = self['z']        m.writefrom(self.s)class entity:    def __init__(self):        self.base = 0x0                self.s = memory_struct()                self.s.add_offset(offset['x'], "x", vartype.float)        self.s.add_offset(offset['y'], "y", vartype.float)        self.s.add_offset(offset['z'], "z", vartype.float)        self.s.add_offset(offset['yaw'], "yaw", vartype.float)        self.s.add_offset(offset['pitch'], "pitch", vartype.float)        self.s.add_offset(offset['roll'], "roll", vartype.float)        self.s.add_offset(offset['health'], "health", vartype.int)                self.s.add_offset(offset['carbine ammo'], "carbine ammo", vartype.int)        self.s.add_offset(offset['shotgun ammo'], "shotgun ammo", vartype.int)        self.s.add_offset(offset['submachine ammo'], "submachine ammo", vartype.int)        self.s.add_offset(offset['sniper ammo'], "sniper ammo", vartype.int)        self.s.add_offset(offset['rifle ammo'], "rifle ammo", vartype.int)        self.s.add_offset(offset['ping'], "ping", vartype.int)        self.s.add_offset(offset['frags'], "frags", vartype.int)        self.s.add_offset(offset['flags'], "flags", vartype.int)        self.s.add_offset(offset['deaths'], "deaths", vartype.int)        self.s.add_offset(offset['score'], "score", vartype.int)                self.s.add_offset(offset['name'], "name", vartype.char_array(16))        self.s.add_offset(offset['team'], "team", vartype.int)                self.vorientation = memvector()        self.vposition = memvector()        def __getitem__(self, key):        if key == "ammo":            for c in ['rifle ammo', 'submachine ammo', 'sniper ammo', 'shotgun ammo', 'carbine ammo']:                if self[c] != 0:                    return self[c]        else:            return self.s[key]        def set_base(self, addr):        self.s.set_base(addr)        self.base = addr            def update(self):        m.readto(self.s)            def set_orientation(self, yaw, pitch, roll):        self.vorientation.init(yaw, pitch, roll)        self.vorientation.write(self.base + offset['yaw'])            def set_position(self, x,y,z):        self.vposition.init(x,y,z)        self.vposition.write(self.base + offset['x'])            def set_yaw(self, yaw):        m.write(self.base + offset['yaw'], vartype.float, yaw)    def set_pitch(self, pitch):        m.write(self.base + offset['pitch'], vartype.float, pitch)    def set_roll(self, roll):        m.write(self.base + offset['roll'], vartype.float, roll)            def set_health(self, value):        m.write(self.base + offset['health'], vartype.int, value)            def set_ammo(self, value):        for c in ['rifle ammo', 'submachine ammo', 'sniper ammo', 'shotgun ammo', 'carbine ammo']:            m.write(self.base + offset[c], vartype.int, value)            def __str__(self):          return str(self.s)            def is_real(self):        if (self['team'] != 0) and (self['team'] != 1):            return False        if self['name'].isspace() or len(self['name']) == 0:            return False        # TODO: more reality checks        return True        def is_alive(self):        return (0 < self['health'] <= 100)            def get_aimto_angle(self, fromx, fromy, fromz):        dx = self['x'] - fromx        dy = self['y'] - fromy        dz = self['z'] - fromz        magnitude = (dx*dx + dy*dy + dz*dz)**0.5                pitch = math.asin(dz/magnitude) * 180 / 3.1415926535        yaw = math.atan2(dy, dx) * 180 / 3.1415926535 + 90        if yaw > 360:            yaw -= 360                return yaw, pitch, 0        class entitylist:    def __init__(self):        self.players = []        self.base = 0x0                self.s = memory_struct()        for i in range(33):            self.s.add_offset(i*0x4, "entity_" + str(i), vartype.int)            self.players.append(entity())            def set_base(self, addr):        self.s.set_base(addr)        self.base = addr            def update(self):        m.readto(self.s)        known_ptrs = []        for i in range(33):            key = "entity_" + str(i)            ptr = self.s[key]                        # prevent repeats            if ptr in known_ptrs:                continue            else:                known_ptrs.append(ptr)                            self.players[i].set_base(ptr)            self.players[i].update()                                                                                        